//_____________________________________________
//
// TestCoverage.C
// KDataStructure
//
// Author: Daniel Wegner <mailto:Daniel.Wegner@student.kit.edu> on 1/13/11.
//
// * Copyright 2011 Karlsruhe Institute of Technology. All rights reserved.
//
// This script generates uniformly distributed true events
// (E_ion,E_heat) in a frame ((EnergyMin,EnergyMax),
// (EnergyMin,EnergyMax)) and scattered experimetal events
// (E_ion,E_heat) around these true values
// The uncertainties depend on the specific detector
// and its resolutions for the energies (E_ion,E_heat)
// The corresponding values for the recoil energy and 
// Q value are calculated and all values are stored in a tree file 

#include "Rtypes.h"
#include "TObject.h"
#include "TFile.h"
#include "TTree.h"
#include "TRandom3.h"
#include "TStopwatch.h"
#include "KQUncertainty.h"
#include "KBoloConfig.h"

TFile* aFile = 0;
TTree* aTree = 0;

void TestCoverage(const Char_t* aFileName,
                  const Char_t* aDetectorName,
                  Int_t aMonteCarloSize,
                  Double_t anEnergyMin,
                  Double_t anEnergyMax)
{
  Double_t anEpsilon = 3;
  aFile = new TFile(aFileName,"RECREATE");
  Double_t anEnergyIonTrue, anEnergyHeatTrue;
  Double_t anEnergyRecoilTrue, aQvalueTrue;
  Double_t anEnergyIonExp, anEnergyHeatExp;
  Double_t anEnergyRecoilExp, aQvalueExp;
  KBoloConfig aBoloConfig(aDetectorName,"BoloConfigFile.txt");
  
  
  Double_t anUncertaintyIonZero = aBoloConfig.GetSigmaIonZero();
  Double_t anUncertaintyHeatZero = aBoloConfig.GetSigmaHeatZero();
  Double_t anUncertaintyIonCalib = aBoloConfig.GetSigmaIonCalibration();
  Double_t anUncertaintyHeatCalib = aBoloConfig.GetSigmaHeatCalibration();
  Double_t aVoltageBias = aBoloConfig.GetChannelVoltage();
  aTree = new TTree("data",
                           "random experimental events generated by"
                           "scattering true events uniformly distributed"
                           "in (E_{ion},E_{heat}) (flat prior)");
  aTree->Branch("EnergyIonTrue",&anEnergyIonTrue);
  aTree->Branch("EnergyHeatTrue",&anEnergyHeatTrue);
  aTree->Branch("EnergyRecoilTrue",&anEnergyRecoilTrue);
  aTree->Branch("QvalueTrue",&aQvalueTrue);
  aTree->Branch("EnergyIonExp",&anEnergyIonExp);
  aTree->Branch("EnergyHeatExp",&anEnergyHeatExp);
  aTree->Branch("EnergyRecoilExp",&anEnergyRecoilExp);
  aTree->Branch("QvalueExp",&aQvalueExp);
  
  Double_t c = aVoltageBias/anEpsilon;
  
  TStopwatch time;
  time.Start();
  for(Int_t k = 0; k<aMonteCarloSize; ++k) {
    anEnergyIonTrue = gRandom->Uniform(anEnergyMin,anEnergyMax);
    anEnergyHeatTrue = gRandom->Uniform(anEnergyMin,anEnergyMax);
    anEnergyRecoilTrue = (1 + c) * anEnergyHeatTrue - c * anEnergyIonTrue;
    aQvalueTrue = anEnergyIonTrue/anEnergyRecoilTrue;
    anEnergyIonExp = gRandom->Gaus(anEnergyIonTrue,
                             KQUncertainty::GetChannelUncertainty(
                               anEnergyIonTrue,
                               anUncertaintyIonZero,
                               anUncertaintyIonCalib));
    anEnergyHeatExp = gRandom->Gaus(anEnergyHeatTrue,
                             KQUncertainty::GetChannelUncertainty(
                               anEnergyHeatTrue,
                               anUncertaintyHeatZero,
                               anUncertaintyHeatCalib));
    anEnergyRecoilExp = (1 + c) * anEnergyHeatExp - c * anEnergyIonExp;
    aQvalueExp = anEnergyIonExp/anEnergyRecoilExp;
    aTree->Fill();
  }
  aTree->Write("",TObject::kOverwrite);
  time.Stop();
  cout << "cpu time: " << time.CpuTime() << endl;
  cout << "real time: " << time.RealTime() << endl;
  
  
}