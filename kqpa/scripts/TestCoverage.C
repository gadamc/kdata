//_____________________________________________
//
// TestCoverage.C
// KDataStructure
//
// Author: Daniel Wegner <mailto:Daniel.Wegner@student.kit.edu> on 1/13/11.
//
// * Copyright 2011 Karlsruhe Institute of Technology. All rights reserved.
//
// This script generates uniformly distributed true events
// (E_ion,E_heat) in a frame ((EnergyMin,EnergyMax),
// (EnergyMin,EnergyMax)) and scattered experimetal events
// (E_ion,E_heat) around these true values
// The uncertainties depend on the specific detector
// and its resolutions for the energies (E_ion,E_heat)
// The corresponding values for the recoil energy and 
// Q value are calculated and all values are stored in a tree file 

#include "Rtypes.h"
#include "TObject.h"
#include "TFile.h"
#include "TTree.h"
#include "TString.h"
#include "TRandom3.h"
#include "TStopwatch.h"
#include "KQUncertainty.h"
#include "KBoloConfig.h"
#include "KQContourPoint.h"
#include "CoverageSelector.h"

TFile* aFile = 0;
TTree* aTree = 0;
Double_t anEpsilon = 3;
Double_t anUncertaintyIonZero = 0;
Double_t anUncertaintyHeatZero = 0;
Double_t anUncertaintyIonCalib = 0;
Double_t anUncertaintyHeatCalib = 0;
Double_t aVoltageBias = 0;
Double_t c = aVoltageBias/anEpsilon;
KQContourPoint* aPoint = 0;

void GetBoloConfig(const Char_t* aDetectorName)
{
  KBoloConfig aBoloConfig(aDetectorName,"BoloConfigFile.txt");
  anUncertaintyIonZero = aBoloConfig.GetSigmaIonZero();
  anUncertaintyHeatZero = aBoloConfig.GetSigmaHeatZero();
  anUncertaintyIonCalib = aBoloConfig.GetSigmaIonCalibration();
  anUncertaintyHeatCalib = aBoloConfig.GetSigmaHeatCalibration();
  aVoltageBias = aBoloConfig.GetChannelVoltage();
  c = aVoltageBias/anEpsilon;
  
}

void TestCoverage(const Char_t* aFileName,
                  const Char_t* aDetectorName,
                  Int_t aMonteCarloSize,
                  Double_t anEnergyMin,
                  Double_t anEnergyMax,
                  Double_t anEnergyRecoil,
                  Double_t aQvalue,
                  Double_t aWidthQvalue = 0.01,
                  Double_t aWidthEnergyRecoil = 0.01,
                  Option_t* anOption = "RECREATE")
{
  GetBoloConfig(aDetectorName);
  aFile = new TFile(aFileName,anOption);
  Double_t anEnergyIonTrue, anEnergyHeatTrue;
  Double_t anEnergyRecoilTrue, aQvalueTrue;
  Double_t anEnergyIonExp, anEnergyHeatExp;
  Double_t anEnergyRecoilExp, aQvalueExp;
  
  

  aTree = new TTree("data",
                           "random experimental events generated by"
                           "scattering true events uniformly distributed"
                           "in (E_{ion},E_{heat}) (flat prior)");
  aTree->Branch("EnergyIonTrue",&anEnergyIonTrue);
  aTree->Branch("EnergyHeatTrue",&anEnergyHeatTrue);
  aTree->Branch("EnergyRecoilTrue",&anEnergyRecoilTrue);
  aTree->Branch("QvalueTrue",&aQvalueTrue);
  aTree->Branch("EnergyIonExp",&anEnergyIonExp);
  aTree->Branch("EnergyHeatExp",&anEnergyHeatExp);
  aTree->Branch("EnergyRecoilExp",&anEnergyRecoilExp);
  aTree->Branch("QvalueExp",&aQvalueExp);

  
  TStopwatch time;
  time.Start();
  for(Int_t k = 0; k<aMonteCarloSize; ++k) {
    anEnergyIonTrue = gRandom->Uniform(anEnergyMin,anEnergyMax);
    anEnergyHeatTrue = gRandom->Uniform(anEnergyMin,anEnergyMax);
    anEnergyRecoilTrue = (1 + c) * anEnergyHeatTrue - c * anEnergyIonTrue;
    aQvalueTrue = anEnergyIonTrue/anEnergyRecoilTrue;
    anEnergyIonExp = gRandom->Gaus(anEnergyIonTrue,
                             KQUncertainty::GetChannelUncertainty(
                               anEnergyIonTrue,
                               anUncertaintyIonZero,
                               anUncertaintyIonCalib));
    anEnergyHeatExp = gRandom->Gaus(anEnergyHeatTrue,
                             KQUncertainty::GetChannelUncertainty(
                               anEnergyHeatTrue,
                               anUncertaintyHeatZero,
                               anUncertaintyHeatCalib));
    anEnergyRecoilExp = (1 + c) * anEnergyHeatExp - c * anEnergyIonExp;
    aQvalueExp = anEnergyIonExp/anEnergyRecoilExp;
    if(aQvalueExp<aQvalue+aWidthQvalue&&
       aQvalueExp>aQvalue&&
       anEnergyRecoilExp<anEnergyRecoil+aWidthEnergyRecoil&&
       anEnergyRecoilExp>anEnergyRecoil)
        aTree->Fill();
  }
  aTree->Write("",TObject::kOverwrite);
  time.Stop();
  cout << "cpu time: " << time.CpuTime() << endl;
  cout << "real time: " << time.RealTime() << endl;
  cout << endl;
  cout << "ion zero: " << anUncertaintyIonZero << endl;
  cout << "ion calib: " << anUncertaintyIonCalib << endl;
  cout << "heat zero: " << anUncertaintyHeatZero << endl;
  cout << "heat calib: " << anUncertaintyHeatCalib << endl;
  
  CoverageSelector* aSelector = 
  (CoverageSelector*)TSelector::GetSelector("CoverageSelector.C+");
  
  
  Double_t anEnergyIon = anEnergyRecoil * aQvalue;
  Double_t anEnergyHeat = (1 + c* aQvalue)/(1+c) * anEnergyRecoil;
  aSelector->MakeContourPoint(anEnergyRecoil,
                              aQvalue,
                              KQUncertainty::GetChannelUncertainty(
                                anEnergyIon,
                                anUncertaintyIonZero,
                                anUncertaintyIonCalib),
                              KQUncertainty::GetChannelUncertainty(
                                anEnergyHeat,
                                anUncertaintyHeatZero,
                                anUncertaintyHeatCalib));
                                
  aTree->Process(aSelector,"",aTree->GetEntries());
  aTree->Draw("QvalueTrue:EnergyRecoilTrue","",
              "colz");
  aPoint = aSelector->GetPoint();
  aPoint->Draw("same");
}

