{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf320
{\fonttbl\f0\fnil\fcharset0 Monaco;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs20 \cf0 Preceed each "wish" with a marker *** and then write your descritption. \
\
*** method to output smaller EdwDS files based upon a time window, specific bolometer, group of bolometers?, calibration data only, Ba gamma calibration only, Wimp only, heat only, fiducial only, coincidence window... the maximum ion pulse offset time is a few milliseconds\
\
*** write methods to access Muon System Event Quality Bits.\
\
*** Maybe we should remove the Samba Sub Records and make that information available as part of the Bolo Sub Record. There is always a Samba record for each Bolo Sub Record - not more, and not less. Given the complications due to having this TRef around, and some potential other bugs that I can't seem to figure out, maybe our lives would be simpler if we just included the samba information in the bolo sub record. eventually, the samba information would migrate to the raw data level, but for now we could put it in the common bolo sub record base. \
\
*** Make Objects Sortable! Looking at page 285 of the ROOT Users's Guide, we can make our objects sortable if we provide two methods, IsSortable and Compare(TObject *obj). The IsSortable will return true and the Compare method will take two objects and return a 1, -1 or 0 depending upon how you want to order them. For example, we could make the subRecords sortable by comparing their event times. This would allow us to sort them by calling the Collection Classes's Sort methods. TObjArray and TClonesArray have Sort methods, which will sort the objects in the collection if those objects have a method IsSortable that returns true and has a Compare method. This might be a very convenient way to implement sorting of the events. \
\
*** Add data access methods to the EdwCoincEvent class. otherwise, its too hard to use because one has to be familiar with the TObjectArray methods and also the Event methods. \
\
*** Add to the EdwAnalysis class a way of finding physics coincidence events and the providing access to those events.\
	group by TRef?? or TRefArray?\
\
*** save a text file in skim file that explains what is in the skim file. \
\
*** Add ability in the code to reproduce the original Muon Data structure and the original Bolo DST files (or others...). This way, "legacy" users could still use their old routines by "using" the new data structures. This task is very very very far down the wish list.\
\
*** Clean up the different filling and merging scripts into one script, which will do the complete job, maybe together with parallel processing.\
\
*** add ability to write out ascii files of the data from the ROOT files for the "old timers"\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f1\fs24 \cf0 ***keep the entire TDC/ADC array somewhere in the system record for now  -- ?? really? we'll see. my routine SHOULD find all events, but it might be easier still for people to read the data with the full array. \
	STATUS - This increases the file size by about a factor of 2. Since this data really shouldn't be here, but should rather be in the "raw" files, I decide to not include it in the HLA events, but rather in the raw events. \
	TODO - move these arrays into the Muon Raw event records whenver the Raw Event Structure gets built.\
\
\
*** implement TString in subRecord classes (and use TClonesArray::Delete instead of TClonesArray::Clear) whenever ROOT releases a new version of the code that includes changes to TTree::Scan/Draw. ROOT v5.28 will be released on June 30 2010 and we can implement this at that time (though we will then force everybody to upgrade to that version of ROOT in order to properly Scan/Draw)\
ALSO - this will increase performance because there are lots of calls allocating and deleting memory just in order to store the names of the detectors! One option is that, since we can't see the bolometer detector names in the TTree Show methods, and because we already include the TCuts, that we just remove the names. They take up unnecessary space and time for allocation. \
\
*** Add a SetStyleEdwPlain method in the Analysis class for a nice unified look of plots.\
	-- good idea! But this might be better to provide a .rootlogon.C file for users instead of putting it into a compiled class. Its not really an analysis function, so it shouldn't go in the Analysis class. Maybe create a "EdwStyle" class?? but still. probably too hard to put this into a compiled class. A rootlogon.C script would contain all of these unified setttings and would be automatically loaded at the beginning of any ROOT session.\
\
--------------------- Completed / Rejected Wish List Items -------------------------------\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs20 \cf0 *** Problematic input files:	jd29c005_tstnew_v1: samba data acquisition restart during file and Anas stamps don't handle this restart; File exluded from rootification. Ana posted a new version of the tstnew file on ccali. Still have to get it and remove the exception.	dst_ID4.root RunName: jl14c001: After the last event of this run name the samba event number restarts in Erics file and he has 831 additional events, which have a clearly a different contents than the first 831events of this run. These events couldn't be found in the tstnew_v1 files or in the samba ntp files 30.04.2010; These 831 events are excluded from insertion. According to Anas Mail from Tu 11.05.10 there are 3 new tstnew files (29.April), which we have to get.\
	STATUS - the new tst files have been downloaded from ccalin on kalinka\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f1\fs24 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs20 \cf0 *** EdwBits class, which inherits from TBits (for now). This class will then have methods to get the different bits with names that make sense (like GetvFlag, or GetChi2Flag, or GetIonFlag(Int_t i)) so its easy for the user to know what they're getting. Later, if we decided that we don't want to pack the bits inside of TBits because it is just an array of Char_t and is somewhat a waste of space, we can rewrite the internal structure to EdwBits without altering how the user access that data. For example, if we stop using TBits, then one idea would be to pack it into a single Int_t, take care of big/little endian issues, and then do bit-wise operations on that word. The great thing about bit-wise operations is that its faster and can be used to "mask" out events with a particular subset of bits set. \
*** STATUS - bad Idea. We want the data tree to be completely independent of classes/lib/dictionary outside of ROOT.\
\
\
*** Perhaps make the BoloSystemRecord and the MuonVetoSystemRecords TClonesArrays in the HLAEvent. We could write a test HLAEvent class (EdwHLAEventTest.cc) and see if using TClonesArrays for these records decreases the size of the files. There will only be zero or one instance in each array. So.. maybe even use a TObjArray for both types of records. 
\f1\fs24 does it make the event more "readable"? does it change the size of the file?\
STATUS - I tried this. Didn't work... it actually increased the size of the file. There is apparently some significant overhead with a TClonesArray. Does that mean its bettern to have no TClonesArray for the bolometers? Is the new data structure extraordinarily inefficient? does the tradeoff in "ease" of analysis worth the inefficiency? do we care if we just break up the final data set into \
\

\f0\fs20 *** should all object's destructors call their Clear methods? In principle, clear should be able to be called as often as possible without any harm. So, I think the answer here should be yes, since Clear is responsible to clean up memory. However, it may result in a performance hit if one is making new and deleting many Events/Records in a program. This behavior normally won't happen, however. \
}